package org.celstec.dao.gen;

import java.util.List;
import org.celstec.dao.gen.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import daoBase.DaoConfiguration;
import org.celstec.arlearn2.beans.dependencies.*;
// KEEP INCLUDES END
/**
 * Entity mapped to table DEPENDENCY_LOCAL_OBJECT.
 */
public class DependencyLocalObject {

    private Long id;
    private Integer type;
    private String action;
    private Integer scope;
    private Long timeDelta;
    private Long radius;
    private Double lat;
    private Double lng;
    private Long parentDependency;
    private Long generalItemId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient DependencyLocalObjectDao myDao;

    private GeneralItemLocalObject generalItemLocalObject;
    private Long generalItemLocalObject__resolvedKey;

    private List<DependencyLocalObject> childDeps;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public DependencyLocalObject() {
    }

    public DependencyLocalObject(Long id) {
        this.id = id;
    }

    public DependencyLocalObject(Long id, Integer type, String action, Integer scope, Long timeDelta, Long radius, Double lat, Double lng, Long parentDependency, Long generalItemId) {
        this.id = id;
        this.type = type;
        this.action = action;
        this.scope = scope;
        this.timeDelta = timeDelta;
        this.radius = radius;
        this.lat = lat;
        this.lng = lng;
        this.parentDependency = parentDependency;
        this.generalItemId = generalItemId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getDependencyLocalObjectDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public Integer getScope() {
        return scope;
    }

    public void setScope(Integer scope) {
        this.scope = scope;
    }

    public Long getTimeDelta() {
        return timeDelta;
    }

    public void setTimeDelta(Long timeDelta) {
        this.timeDelta = timeDelta;
    }

    public Long getRadius() {
        return radius;
    }

    public void setRadius(Long radius) {
        this.radius = radius;
    }

    public Double getLat() {
        return lat;
    }

    public void setLat(Double lat) {
        this.lat = lat;
    }

    public Double getLng() {
        return lng;
    }

    public void setLng(Double lng) {
        this.lng = lng;
    }

    public Long getParentDependency() {
        return parentDependency;
    }

    public void setParentDependency(Long parentDependency) {
        this.parentDependency = parentDependency;
    }

    public Long getGeneralItemId() {
        return generalItemId;
    }

    public void setGeneralItemId(Long generalItemId) {
        this.generalItemId = generalItemId;
    }

    /** To-one relationship, resolved on first access. */
    public GeneralItemLocalObject getGeneralItemLocalObject() {
        Long __key = this.generalItemId;
        if (generalItemLocalObject__resolvedKey == null || !generalItemLocalObject__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GeneralItemLocalObjectDao targetDao = daoSession.getGeneralItemLocalObjectDao();
            GeneralItemLocalObject generalItemLocalObjectNew = targetDao.load(__key);
            synchronized (this) {
                generalItemLocalObject = generalItemLocalObjectNew;
            	generalItemLocalObject__resolvedKey = __key;
            }
        }
        return generalItemLocalObject;
    }

    public void setGeneralItemLocalObject(GeneralItemLocalObject generalItemLocalObject) {
        synchronized (this) {
            this.generalItemLocalObject = generalItemLocalObject;
            generalItemId = generalItemLocalObject == null ? null : generalItemLocalObject.getId();
            generalItemLocalObject__resolvedKey = generalItemId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<DependencyLocalObject> getChildDeps() {
        if (childDeps == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            DependencyLocalObjectDao targetDao = daoSession.getDependencyLocalObjectDao();
            List<DependencyLocalObject> childDepsNew = targetDao._queryDependencyLocalObject_ChildDeps(id);
            synchronized (this) {
                if(childDeps == null) {
                    childDeps = childDepsNew;
                }
            }
        }
        return childDeps;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetChildDeps() {
        childDeps = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    private static final int ACTION_DEPENDENCY = 1;
    private static final int AND_DEPENDENCY = 2;
    private static final int OR_DEPENDENCY = 3;
    private static final int TIME_DEPENDENCY = 4;
    private static final int PROXIMITY_DEPENDENCY = 5;
    private static final long NOT_SATISFIED= -1;


    public String toString() {
        switch (getType()) {
            case ACTION_DEPENDENCY:
                return toStringAction();
            case TIME_DEPENDENCY:
                return toStringTime();
            case PROXIMITY_DEPENDENCY:
                return toStringProximity();
            case AND_DEPENDENCY:
                return toStringAnd();
            case OR_DEPENDENCY:
                return toStringOr();
        }
        return "root class dependency "+getId();
    }

    private String toStringAction() {
        return "(action: "+getId()+":"+getAction()+")";
    }

    private String toStringTime() {
        return "(time: "+getId()+":"+getTimeDelta()+(!getChildDeps().isEmpty()?getChildDeps().get(0).toString():"")+")";
    }

    private String toStringProximity() {
        return "(prox: "+getId()+":"+getRadius()+":"+getLat()+":"+getLng()+")";
    }

    private String toStringAnd() {
        String retString = "[and: ";
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            retString += dependencyLocalObject.toString();
        }
        return retString+"]";
    }

    private String toStringOr() {
        String retString = "[or: ";
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            retString += dependencyLocalObject.toString();
        }
        return retString+"]";
    }

    public DependencyLocalObject(ActionDependency dependsOn) {
        setType(ACTION_DEPENDENCY);
        setAction(dependsOn.getAction());
        setGeneralItemId(dependsOn.getGeneralItemId());
        setScope(dependsOn.getScope());
        DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(this);
    }

    public DependencyLocalObject(TimeDependency dependsOn) {
        setType(TIME_DEPENDENCY);
        setTimeDelta(dependsOn.getTimeDelta());
        DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(this);
        if (dependsOn.getOffset()!= null) {
            DependencyLocalObject localObject = DependencyLocalObject.createDependencyLocalObject(dependsOn.getOffset());
            localObject.setParentDependency(this.getId());
            DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(localObject);
        }
    }

    public DependencyLocalObject(ProximityDependency dependsOn) {
        setType(PROXIMITY_DEPENDENCY);
        if (dependsOn.getRadius()!=null) setRadius((long) dependsOn.getRadius().intValue());
        setLat(dependsOn.getLat());
        setLng(dependsOn.getLng());
        DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(this);

    }

    public DependencyLocalObject(AndDependency dependencyBean) {
        setType(AND_DEPENDENCY);
        DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(this);
        for (Dependency dep: dependencyBean.getDependencies()){
            DependencyLocalObject localObject = DependencyLocalObject.createDependencyLocalObject(dep);
            localObject.setParentDependency(this.getId());
            DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(localObject);
        }
    }

    public DependencyLocalObject(OrDependency dependencyBean) {
        setType(OR_DEPENDENCY);
        DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(this);
        for (Dependency dep: dependencyBean.getDependencies()){
            DependencyLocalObject localObject = DependencyLocalObject.createDependencyLocalObject(dep);
            localObject.setParentDependency(this.getId());
            DaoConfiguration.getInstance().getDependencyLocalObjectDao().insertOrReplace(localObject);
        }
    }

    public static DependencyLocalObject createDependencyLocalObject(Dependency dependsOn) {
        if ("org.celstec.arlearn2.beans.dependencies.ActionDependency".equals(dependsOn.getType())) {
            return new DependencyLocalObject((ActionDependency)dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.AndDependency".equals(dependsOn.getType())) {
            return new DependencyLocalObject((AndDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.OrDependency".equals(dependsOn.getType())) {
            return new DependencyLocalObject((OrDependency) dependsOn);
        }  else if ("org.celstec.arlearn2.beans.dependencies.TimeDependency".equals(dependsOn.getType())) {
            return new DependencyLocalObject((TimeDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.ProximityDependency".equals(dependsOn.getType())) {
            return new DependencyLocalObject((ProximityDependency) dependsOn);
        }
        return null;
    }

    public boolean recursiveEquals(Dependency dependsOn) {
        if ("org.celstec.arlearn2.beans.dependencies.ActionDependency".equals(dependsOn.getType())) {
            if (ACTION_DEPENDENCY == getType()) return recursiveEquals((ActionDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.AndDependency".equals(dependsOn.getType())) {
            if (AND_DEPENDENCY == getType()) return recursiveEqualsAndOr((BooleanDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.OrDependency".equals(dependsOn.getType())) {
            if (OR_DEPENDENCY == getType()) return recursiveEqualsAndOr((BooleanDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.TimeDependency".equals(dependsOn.getType())) {
            if (TIME_DEPENDENCY == getType()) return recursiveEquals((TimeDependency) dependsOn);
        } else if ("org.celstec.arlearn2.beans.dependencies.ProximityDependency".equals(dependsOn.getType())) {
            if (PROXIMITY_DEPENDENCY == getType()) return recursiveEquals((ProximityDependency) dependsOn);
        }
        return false;
    }

    public boolean recursiveEquals(ActionDependency ad) {
        return (nullSafeEquals(getAction(), ad.getAction())
                && nullSafeEquals(getGeneralItemId(), ad.getGeneralItemId())
                && nullSafeEquals(getScope(), ad.getScope()));
    }

    public boolean recursiveEquals(TimeDependency ad) {
        if (getChildDeps().isEmpty()) return false;
        if (ad.getOffset()== null) return false;
        return (nullSafeEquals(getTimeDelta(), ad.getTimeDelta())
                && getChildDeps().get(0).recursiveEquals(ad.getOffset()));
    }

    public boolean recursiveEquals(ProximityDependency ad) {
        return (nullSafeEquals(getRadius(), ad.getRadius())
                && nullSafeEquals(getLat(), ad.getLat())
                && nullSafeEquals(getLng(), ad.getLng()));
    }

    public boolean recursiveEqualsAndOr(BooleanDependency ad) {
        if (this.getChildDeps().size() != ad.getDependencies().size()) return false;
        int i = 0;
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            if (!dependencyLocalObject.recursiveEquals(ad.getDependencies().get(i++))) return false;
        }
        return true;
    }

    protected boolean nullSafeEquals(Object o1, Object o2) {
        if (o2 == null || o1 == o2) return true;
        if (o1 == null) return false;
        if (o1.getClass() != o2.getClass()) return false;
        return o1.equals(o2);
    }

    public void recursiveDelete() {
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            dependencyLocalObject.recursiveDelete();
        }
        this.delete();
    }

    public long satisfiedAt(RunLocalObject run) {
        switch (getType()) {
            case ACTION_DEPENDENCY:
                return actionSatisfiedAt(run);
            case TIME_DEPENDENCY:
                return timeSatisfiedAt(run);
            case PROXIMITY_DEPENDENCY:
                return proximitySatisfiedAt(run);
            case AND_DEPENDENCY:
                return andSatisfiedAt(run);
            case OR_DEPENDENCY:
                return orSatisfiedAt(run);
        }
        return -1;
    }

    private long orSatisfiedAt(RunLocalObject run) {
        long minTime = Long.MAX_VALUE;
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            long localMin = dependencyLocalObject.satisfiedAt(run);
            if (localMin != -1) minTime = Math.min(minTime, localMin);
        }
        if (minTime == Long.MAX_VALUE) return -1;
        return minTime;
    }

    private long andSatisfiedAt(RunLocalObject run) {
        long maxTime = 0;
        for (DependencyLocalObject dependencyLocalObject: this.getChildDeps()) {
            long localMax = dependencyLocalObject.satisfiedAt(run);
            if (localMax == -1) return localMax;
            maxTime = Math.max(maxTime, localMax);
        }
        return maxTime;
    }


    private long actionSatisfiedAt(RunLocalObject run) {
        long minSatisfiedAt = Long.MAX_VALUE;
        if (getGeneralItemId() != null) {
            for (ActionLocalObject action :getGeneralItemLocalObject().getActions()){
                if (action.getRunId() == run.getId()) {
                    long newValue =                                   actionSatisfiedAt(action);
                    minSatisfiedAt = Math.min(minSatisfiedAt,newValue);
                }
            }
        } else {
            for (ActionLocalObject action :run.getActions()){
                minSatisfiedAt = Math.min(minSatisfiedAt, actionSatisfiedAt(action));
            }
        }
        if (minSatisfiedAt == Long.MAX_VALUE) minSatisfiedAt = -1;
        return minSatisfiedAt;
    }

    private long timeSatisfiedAt(RunLocalObject run) {
       if (getChildDeps().isEmpty()) return -1;
       long satisfiedAt = getChildDeps().get(0).satisfiedAt(run);
        if (satisfiedAt == -1) return -1;
        return  satisfiedAt + timeDelta;
    }

    private long proximitySatisfiedAt(RunLocalObject run) {
        long minSatisfiedAt = Long.MAX_VALUE;
        String latString = ""+((double)(long)(getLat()*1000000)/1000000);
        String lngString = ""+((double)(long)(getLng()*1000000)/1000000);
        String compString ="geo:"+latString+":"+lngString+":"+radius;
        for (ActionLocalObject action :run.getActions()){
            if ((compString).equals(action.getAction())){
                minSatisfiedAt = Math.min(minSatisfiedAt, (action.getTime()==null)?0:action.getTime());
            }
        }
        if (minSatisfiedAt == Long.MAX_VALUE) minSatisfiedAt = -1;
        return minSatisfiedAt;
    }

    private long actionSatisfiedAt(ActionLocalObject action) {
        boolean tempBool = true;
        if (!nullSafeEquals(action.getAction(), getAction())) tempBool = false;
        if (!nullSafeEquals(action.getGeneralItem(), getGeneralItemId())) tempBool = false;
        //TODO roles
        if (tempBool) return action.getTime()==null?0:action.getTime();
        return Long.MAX_VALUE;
    }
    // KEEP METHODS END

}
